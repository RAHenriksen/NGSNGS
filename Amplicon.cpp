#include "Briggs.h"
#include "mrand.h"
#include "fasta_sampler.h"
#include "NtSubModels.h"
#include "add_indels.h"
#include "HelpPage.h"
#include "Amplicon_cli.h"

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <cstdint>
#include <cmath>
#include <string>
#include <iostream>

#include <htslib/faidx.h>
#include <htslib/sam.h>
#include <htslib/vcf.h>
#include <htslib/bgzf.h>
#include <htslib/kstring.h>
#include <htslib/kseq.h>

#define LENS 4096

pthread_mutex_t amplicon_write_mutex = PTHREAD_MUTEX_INITIALIZER;

typedef struct {
  BGZF* amplicon_in_fp;
  int startLine;
  int endLine;
  int threadid;
  char* Briggs;
  char* Indel;
  int rng_type;
  BGZF* amplicon_out_fp;  // Include the output file in the thread struct
  long int Seed;

  double* MisMatch;
  int MisLength;
  int doMisMatchErr;

  size_t moduloread;

} struct_for_amplicon_threads;

KSEQ_INIT(BGZF*, bgzf_read);

void* ProcessFQ(void* args) {
  struct_for_amplicon_threads* amp_thread_struct = (struct_for_amplicon_threads*)args;

  BGZF* amplicon_in_fp = amp_thread_struct->amplicon_in_fp;
  BGZF* amplicon_out_fp = amp_thread_struct->amplicon_out_fp;
  int startLine = amp_thread_struct->startLine;
  int endLine = amp_thread_struct->endLine;
  int threadid = amp_thread_struct->threadid;

  //char* Briggs = amp_thread_struct->Briggs;
  //char* IndelInputParam = amp_thread_struct->Indel;

  long int Seed = amp_thread_struct->Seed;

  fprintf(stderr,"Using the provided seed %lu \n",Seed);
  //fprintf(stderr,"initialize thread %d reading chunk starting from line %d to ending line %d\n",threadid,startLine,endLine);
  
  // Initialize briggs parameters
  float Param[4];
  if (amp_thread_struct->Briggs != NULL){
    char* BriggsParam;
    BriggsParam = strdup(amp_thread_struct->Briggs);
    Param[0] = atof(strtok(BriggsParam,"\", \t"));
    Param[1] = atof(strtok(NULL,"\", \t"));
    Param[2] = atof(strtok(NULL,"\", \t"));
    Param[3] = atof(strtok(NULL,"\", \t"));
      
    free(BriggsParam);
  }

  float IndelFuncParam[4];
  if (amp_thread_struct->Indel != NULL){
    char* IndelInputParam = strdup(amp_thread_struct->Indel);
    IndelFuncParam[0] = atof(strtok(IndelInputParam,"\", \t"));
    IndelFuncParam[1] = atof(strtok(NULL,"\", \t"));
    IndelFuncParam[2] = atof(strtok(NULL,"\", \t"));
    IndelFuncParam[3] = atof(strtok(NULL,"\", \t"));
    
    free(IndelInputParam); 
  }

  //generating kstring for potential records of the stochastic indels
  char INDEL_INFO[1024];  

  // Count the number of processed reads  fprintf(stderr,"\t-> Number of reads generated by thread %d is %zu \n",struct_obj->threadno,localread);
  size_t moduloread = amp_thread_struct->moduloread;
  size_t localread = 0;
  size_t current_reads_atom = 0;

  //allocate the random generator
  mrand_t *mr = mrand_alloc(amp_thread_struct->rng_type,Seed);

  // Seek to the appropriate starting line
  kseq_t *FQseq = kseq_init(amplicon_in_fp);
  while (startLine <= endLine){
    //fprintf(stderr,"line %d\n",startLine);
    if (kseq_read(FQseq) < 0) {
      //fprintf(stderr, "Error reading sequence in thread %d\n", threadid);
      break;    
    }

    localread++;
    current_reads_atom++;
    //printing out every tenth of the runtime
    if (current_reads_atom > 1 && current_reads_atom%moduloread == 0)
      fprintf(stderr,"\t-> Processed %zu reads with a current total of %zu\n",moduloread,current_reads_atom);

    // Sequence alteration integers
    int FragMisMatch = 0;
    int has_indels = 0;
    int ReadDeam=0;

    // deamination
    if (amp_thread_struct->Briggs != NULL){
      int strand = mrand_pop(mr)>0.5?0:1;
      ReadDeam = SimBriggsModel_amplicon(&FQseq->seq,Param[0],Param[1],Param[2],Param[3], mr);
    }

    // Mismatch matrix input file
    if(amp_thread_struct->doMisMatchErr > 0){
      //fprintf(stderr,"INSIDE mf\n");    
      FragMisMatch = MisMatchFile_kstring(&FQseq->seq,mr,amp_thread_struct->MisMatch,amp_thread_struct->MisLength);
      //fprintf(stderr,"FragMisMatch val %d \n",FragMisMatch);
    }

    // Stochastic structural variation model    
    if(amp_thread_struct->Indel != NULL){
      double pars[4] = {IndelFuncParam[0],IndelFuncParam[1],IndelFuncParam[2],IndelFuncParam[3]};
      //fprintf(stderr,"adding stochastic indels with parameters %f \t %f \t %f \t %f\n",pars[0],pars[1],pars[2],pars[3]);

      int ErrProbTypeOffset=33; //only for fastq i should be 0 for bam

      int ops[2] ={0,0};

      if(pars[1] == 0){
        //only potential insertions
        if(mrand_pop(mr)<pars[0]){
          add_indel_amplicon_fqbam(mr,&FQseq->seq,&FQseq->qual,pars,ops,ErrProbTypeOffset);
        }
        else{
          continue;
        }
      }
      else if(pars[0] == 0){
        //only potential deletions
        if(mrand_pop(mr)<pars[1]){
          add_indel_amplicon_fqbam(mr,&FQseq->seq,&FQseq->qual,pars,ops,ErrProbTypeOffset);
        }
        else{
          continue;
        }
      }
      else if(mrand_pop(mr)<pars[0] && mrand_pop(mr)<pars[1]){
        add_indel_amplicon_fqbam(mr,&FQseq->seq,&FQseq->qual,pars,ops,ErrProbTypeOffset);
      }

      //fprintf(stderr,"done adding insertions sequence for read \n\t%s\n\t%s\n\t%s\t\n with sizes seq %d \t qual %d\n",FQseq->name.s,FQseq->seq.s,FQseq->qual.s,FQseq->seq.l,FQseq->qual.l);
      if (ops[0] > 0 && ops[1] == 0){
        has_indels = 1;
      }
      else if (ops[0] == 0 && ops[1] > 0){
        has_indels = 2;
      }
      else if (ops[0] > 0 && ops[1] > 0){
        has_indels = 3;
      }

      //fprintf(stderr,"indel value %d\n",has_indels);
    }

    //kseq_read(seq);
    kstring_t thread_out = {0, 0, NULL};  // Initialize kstring_t for the formatted output
    ksprintf(&thread_out, "%s_mod%d%d%d\n%s\n+\n%s\n",FQseq->name.s,ReadDeam,FragMisMatch,has_indels,FQseq->seq.s, FQseq->qual.s);
    //fprintf(stderr,"TID%d_line%d_%s\t%s\t+\t%s\n", threadid, startLine,seq->name.s, seq->seq.s, seq->qual.s);
    pthread_mutex_lock(&amplicon_write_mutex);
    if (bgzf_write(amplicon_out_fp, thread_out.s, thread_out.l) < 0) {
      fprintf(stderr, "Error writing to output file in thread %d\n", threadid);
    }
    //assert(bgzf_write(amplicon_out_fp, thread_out.s, thread_out.l) != 0);
    pthread_mutex_unlock(&amplicon_write_mutex);

    free(thread_out.s);
    startLine++;
    //fprintf(stderr,"thread %d \t startline %d\n",threadid,startLine);
  }

  kseq_destroy(FQseq);

  return NULL;
}

#ifdef __WITH_MAIN__

int main(int argc,char **argv){
  argStruct *mypars = NULL;
  mypars = amplicongetpars(argc,argv);
  
  if(argc==1||(argc==2&&(strcasecmp(argv[1],"--help")==0||strcasecmp(argv[1],"-h")==0))){
    HelpPage(stderr);
    return 0;
  }
  // Initate parameters

  const char* Amplicon_in_fp = mypars->Amplicon_in_pars;
  const char* Amplicon_out_fp = mypars->Amplicon_out_pars;
  int threads = mypars->Threads;
  char *Briggs = mypars->BriggsBiotin;
  char *Indel = mypars->Indel;
  //const char* fastqFile = "Amplicon_in.fq";
  long int Seed = mypars->Seed;
  if (mypars->rng_type == -1){
    #if defined(__linux__) || defined(__unix__)
      mypars->rng_type = 0;
    #elif defined(__APPLE__) || defined(__MACH__)
      mypars->rng_type = 3;
      //when 0 it will have problems with drand48 reentrant, will default to erand48 (MacroRandType 3)
    #else
    #   error "Unknown compiler"
    #endif
  }

  // Count the total number of lines in the file
  long long totalLines = 0;

  BGZF* fp_tmp = bgzf_open(Amplicon_in_fp, "r");
  kstring_t linecounttmp;linecounttmp.s=NULL;linecounttmp.l=linecounttmp.m=0; // Initialize a kstring_t structure
  while (bgzf_getline(fp_tmp, '\n', &linecounttmp) != -1){totalLines++;}
  free(linecounttmp.s);
  
  // Calculate the number of lines per thread
  size_t no_reads = totalLines/4;
  size_t linesPerThread = totalLines / threads;
  bgzf_close(fp_tmp);

  int modulovalue;
  if (no_reads > 100){
    modulovalue = 10;
  }
  else{ 
    modulovalue = 1;
  }
  size_t moduloread = no_reads/modulovalue;

  //printf("Total lines %zu \t Total reads %zu \t lines pr threads %zu \n",totalLines,no_reads,linesPerThread);

  //generating mismatch matrix to parse for each string
  double* MisMatchFreqArray = new double[LENS];
  int mismatchcyclelength = 0;
  int doMisMatchErr = 0;
  if (mypars->SubProfile != NULL){
    MisMatchFreqArray = MisMatchFileArray(MisMatchFreqArray,mypars->SubProfile,mismatchcyclelength);
    doMisMatchErr = 1;
  }

  if(strcasecmp("-indel",*argv)==0){
    mypars->Indel = strdup(*(++argv));
  }

  BGZF* fp = bgzf_open(Amplicon_in_fp, "r");
  if (fp == NULL) {
    fprintf(stderr, "Error opening the FastQ file.\n");
    return 1;
  }

  BGZF* amplicon_out = bgzf_open(Amplicon_out_fp, "wu");
  if (amplicon_out == NULL) {
    fprintf(stderr, "Error opening output file.\n");
    return 1;
  }

  // Create an array to hold thread IDs dynamically
  pthread_t* mythreads = new pthread_t[threads];

  // Create an array to hold thread arguments dynamically
  struct_for_amplicon_threads* amp_thread_struct = new struct_for_amplicon_threads[threads];

  // Create threads dynamically
  for (int i = 0; i < threads; ++i) {
    int startLine = i * linesPerThread+1;
    int endLine = (i == threads - 1) ? totalLines : startLine + linesPerThread - 1;

    //fprintf(stderr, "Thread %d reads in line start %d to line end %d\n", i, startLine, endLine);
    amp_thread_struct[i].moduloread = moduloread;
    amp_thread_struct[i].amplicon_in_fp = fp;
    amp_thread_struct[i].amplicon_out_fp = amplicon_out;
    amp_thread_struct[i].Briggs = Briggs;
    amp_thread_struct[i].startLine = startLine;
    amp_thread_struct[i].endLine = endLine;
    amp_thread_struct[i].threadid = i;
    amp_thread_struct[i].Seed = Seed; 
    amp_thread_struct[i].rng_type = mypars->rng_type;

    // 3) misincorporation matrix
    amp_thread_struct[i].MisMatch = MisMatchFreqArray;
    amp_thread_struct[i].MisLength = (int) mismatchcyclelength;
    amp_thread_struct[i].doMisMatchErr = doMisMatchErr;

    // Random indels
    amp_thread_struct[i].Indel = Indel;

    // Create each thread
    pthread_create(&mythreads[i], NULL, ProcessFQ, &amp_thread_struct[i]);
  }
  
  // Wait for all threads to finish
  for (int i = 0; i < threads; ++i) {
    pthread_join(mythreads[i], NULL);
    //fprintf(stderr, "Thread %d finished\n", i+1);
  }

  // Delete allocated memory
  delete[] mythreads;
  delete[] amp_thread_struct;

  // Close the files
  bgzf_close(amplicon_out);
  bgzf_close(fp);

  fprintf(stderr, "done writing the altered amplicon file\n");
  
  return 0;
}
#endif

/*
g++ Amplicon.cpp -lz -lm -lbz2 -llzma -lpthread -lcurl -lcrypto ../mrand.o ../Briggs.o ../NtSubModels.o ../add_indels.o ../../htslib/libhts.a -D __WITH_MAIN__ -o Amplicon

./Amplicon --amplicon Amplicon_in.fq -m b,0.024,0.36,0.68,0.0097 -mf ../Test_Examples/MisincorpFile.txt --output Amplicon_out.fq

Deletions
./Amplicon --amplicon Amplicon_in.fq -indel 0.0,0.5,0.0,0.9 --output Amplicon_out.fq -t 1

Insertions
./Amplicon --amplicon Amplicon_in.fq -indel 0.05,0.0,0.1,0.0 --output Amplicon_out.fq -t 1

./Amplicon --amplicon Amplicon_in.fq --output Amplicon_out.fq --threads 2


*/
