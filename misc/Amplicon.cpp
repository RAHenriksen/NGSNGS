#include "../Briggs.h"
#include "../mrand.h"
#include "../fasta_sampler.h"
#include "../NtSubModels.h"
#include "../add_indels.h"

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <cstdint>
#include <cmath>
#include <string>
#include <iostream>

#include <htslib/faidx.h>
#include <htslib/sam.h>
#include <htslib/vcf.h>
#include <htslib/bgzf.h>
#include <htslib/kstring.h>
#include <htslib/kseq.h>

#define LENS 4096

pthread_mutex_t write_mutex = PTHREAD_MUTEX_INITIALIZER;

// Define parameters

typedef struct{
  const char* Amplicon_in_pars;
  const char* Amplicon_out_pars;
  char *BriggsBiotin;  //the four briggs parameters in relation to Biotin
  char *Indel;         //the four indel parameters in relation to random indels
  int Threads;
  long int Seed;
  char *SubProfile;           //filename for misincorperation, typespecific and position specific
}argStruct;

argStruct *getpars(int argc,char ** argv){
  argStruct *mypars = new argStruct;

  mypars->Amplicon_in_pars = NULL;
  mypars->Amplicon_out_pars = NULL;
  mypars->BriggsBiotin = NULL;
  mypars->Threads = 1;
  mypars->Seed = (int) time(NULL);
  // 3) misincorporation matrix
  mypars->SubProfile = NULL;
  mypars->Indel = NULL;

  ++argv;
  while(*argv){
    if(strcasecmp("-a",*argv)==0 || strcasecmp("--amplicon",*argv)==0){
      mypars->Amplicon_in_pars = strdup(*(++argv));
    }
    else if(strcasecmp("-o",*argv)==0 || strcasecmp("--output",*argv)==0){
      mypars->Amplicon_out_pars = strdup(*(++argv));
    }
    else if(strcasecmp("-m",*argv)==0 || strcasecmp("--model",*argv)==0){
      ++argv;
      char *tok = *argv;
      char* ModelString = strdup(tok);
      char* BriggsModel;
      BriggsModel = strtok(ModelString,",");
      char* ModelParam =  strdup(strtok (NULL, ""));
      if(strcasecmp("b",BriggsModel)==0 || strcasecmp("briggs",BriggsModel)==0 || strcasecmp("b7",BriggsModel)==0 || strcasecmp("briggs07",BriggsModel)==0)
	      mypars->BriggsBiotin = ModelParam;

      free(ModelString);
    }
    else if(strcasecmp("-t",*argv)==0 || strcasecmp("--threads",*argv)==0){
      mypars->Threads = atoi(*(++argv));
    }
    else if(strcasecmp("-s",*argv)==0 || strcasecmp("--seed",*argv)==0){
      mypars->Seed = atol(*(++argv));
    }
    else if(strcasecmp("-mf",*argv)==0 || strcasecmp("--mismatch",*argv)==0){
      mypars->SubProfile = strdup(*(++argv));
    }
    else if(strcasecmp("-indel",*argv)==0){
      mypars->Indel = strdup(*(++argv));
    }
    else{
      fprintf(stderr,"unrecognized input option %s, see help page\n\n",*(argv));
      exit(0);
    }
    ++argv;
  }
  return mypars;
}

// Define a struct to store the information from a FastQ record
typedef struct {
    char* header;
    char* sequence;
    char* quality;
} FastQRecord;

typedef struct {
  BGZF* amplicon_in_fp;
  int startLine;
  int endLine;
  int threadid;
  char* Briggs;
  char* Indel;

  BGZF* amplicon_out_fp;  // Include the output file in the thread struct
  long int Seed;

  double* MisMatch;
  int MisLength;
  int doMisMatchErr;

  size_t moduloread;

} struct_for_amplicon_threads;


KSEQ_INIT(BGZF*, bgzf_read);

void* ProcessChunk(void* args) {
  struct_for_amplicon_threads* amp_thread_struct = (struct_for_amplicon_threads*)args;

  BGZF* amplicon_in_fp = amp_thread_struct->amplicon_in_fp;
  BGZF* amplicon_out_fp = amp_thread_struct->amplicon_out_fp;
  int startLine = amp_thread_struct->startLine;
  int endLine = amp_thread_struct->endLine;
  int threadid = amp_thread_struct->threadid;

  //char* Briggs = amp_thread_struct->Briggs;
  //char* IndelInputParam = amp_thread_struct->Indel;

  long int Seed = amp_thread_struct->Seed;

  fprintf(stderr,"Using the provided seed %lu \n",Seed);
  //fprintf(stderr,"initialize thread %d reading chunk starting from line %d to ending line %d\n",threadid,startLine,endLine);
  
  // Initialize briggs parameters
  float Param[4];
  if (amp_thread_struct->Briggs != NULL){
    char* BriggsParam;
    BriggsParam = strdup(amp_thread_struct->Briggs);
    Param[0] = atof(strtok(BriggsParam,"\", \t"));
    Param[1] = atof(strtok(NULL,"\", \t"));
    Param[2] = atof(strtok(NULL,"\", \t"));
    Param[3] = atof(strtok(NULL,"\", \t"));
      
    free(BriggsParam);
  }

  float IndelFuncParam[4];
  if (amp_thread_struct->Indel != NULL){
    char* IndelInputParam = strdup(amp_thread_struct->Indel);
    IndelFuncParam[0] = atof(strtok(IndelInputParam,"\", \t"));
    IndelFuncParam[1] = atof(strtok(NULL,"\", \t"));
    IndelFuncParam[2] = atof(strtok(NULL,"\", \t"));
    IndelFuncParam[3] = atof(strtok(NULL,"\", \t"));
    
    free(IndelInputParam); 
  }

  //generating kstring for potential records of the stochastic indels
  char INDEL_INFO[1024];  

  // Count the number of processed reads  fprintf(stderr,"\t-> Number of reads generated by thread %d is %zu \n",struct_obj->threadno,localread);
  size_t moduloread = amp_thread_struct->moduloread;
  size_t localread = 0;
  size_t current_reads_atom = 0;

  //allocate the random generator
  mrand_t *mr = mrand_alloc(0,Seed);

  // Seek to the appropriate starting line
  kseq_t *FQseq = kseq_init(amplicon_in_fp);
  while (startLine <= endLine){
    //fprintf(stderr,"line %d\n",startLine);
    if (kseq_read(FQseq) < 0) {
      //fprintf(stderr, "Error reading sequence in thread %d\n", threadid);
      break;    
    }

    localread++;
    current_reads_atom++;
    //printing out every tenth of the runtime
    if (current_reads_atom > 1 && current_reads_atom%moduloread == 0)
      fprintf(stderr,"\t-> Processed %zu reads with a current total of %zu\n",moduloread,current_reads_atom);

    // Sequence alteration integers
    int FragMisMatch = 0;
    int has_indels = 0;
    int ReadDeam=0;

    // deamination
    if (amp_thread_struct->Briggs != NULL){
      int strand = mrand_pop(mr)>0.5?0:1;
      ReadDeam = SimBriggsModel_amplicon(&FQseq->seq,Param[0],Param[1],Param[2],Param[3], mr);
    }

    // Mismatch matrix input file
    if(amp_thread_struct->doMisMatchErr > 0){
      //fprintf(stderr,"INSIDE mf\n");    
      FragMisMatch = MisMatchFile_kstring(&FQseq->seq,mr,amp_thread_struct->MisMatch,amp_thread_struct->MisLength);
      //fprintf(stderr,"FragMisMatch val %d \n",FragMisMatch);
    }

    // Stochastic structural variation model    
    if(amp_thread_struct->Indel != NULL){
      double pars[4] = {IndelFuncParam[0],IndelFuncParam[1],IndelFuncParam[2],IndelFuncParam[3]};
      //fprintf(stderr,"adding stochastic indels with parameters %f \t %f \t %f \t %f\n",pars[0],pars[1],pars[2],pars[3]);

      int ErrProbTypeOffset=33; //only for fastq i should be 0 for bam

      int ops[2] ={0,0};

      if(pars[1] == 0){
        //only potential insertions
        if(mrand_pop(mr)<pars[0]){
          add_indel_amplicon_fqbam(mr,&FQseq->seq,&FQseq->qual,pars,ops,ErrProbTypeOffset);
        }
        else{
          continue;
        }
      }
      else if(pars[0] == 0){
        //only potential deletions
        if(mrand_pop(mr)<pars[1]){
          add_indel_amplicon_fqbam(mr,&FQseq->seq,&FQseq->qual,pars,ops,ErrProbTypeOffset);
        }
        else{
          continue;
        }
      }
      else if(mrand_pop(mr)<pars[0] && mrand_pop(mr)<pars[1]){
        add_indel_amplicon_fqbam(mr,&FQseq->seq,&FQseq->qual,pars,ops,ErrProbTypeOffset);
      }

      //fprintf(stderr,"done adding insertions sequence for read \n\t%s\n\t%s\n\t%s\t\n with sizes seq %d \t qual %d\n",FQseq->name.s,FQseq->seq.s,FQseq->qual.s,FQseq->seq.l,FQseq->qual.l);
      if (ops[0] > 0 && ops[1] == 0){
        has_indels = 1;
      }
      else if (ops[0] == 0 && ops[1] > 0){
        has_indels = 2;
      }
      else if (ops[0] > 0 && ops[1] > 0){
        has_indels = 3;
      }

      //fprintf(stderr,"indel value %d\n",has_indels);
    }

    //kseq_read(seq);
    //fprintf(stderr,"thread %d for current line %d and end line %d\n",threadid,currentLine,endLine);
    kstring_t thread_out = {0, 0, NULL};  // Initialize kstring_t for the formatted output
    ksprintf(&thread_out, "%s_mod%d%d%d\n%s\n+\n%s\n",FQseq->name.s,ReadDeam,FragMisMatch,has_indels,FQseq->seq.s, FQseq->qual.s);
    //fprintf(stderr,"TID%d_line%d_%s\t%s\t+\t%s\n", threadid, startLine,seq->name.s, seq->seq.s, seq->qual.s);
    pthread_mutex_lock(&write_mutex);
    if (bgzf_write(amplicon_out_fp, thread_out.s, thread_out.l) < 0) {
      fprintf(stderr, "Error writing to output file in thread %d\n", threadid);
    }
    //assert(bgzf_write(amplicon_out_fp, thread_out.s, thread_out.l) != 0);
    pthread_mutex_unlock(&write_mutex);

    free(thread_out.s);
    startLine++;
    //fprintf(stderr,"thread %d \t startline %d\n",threadid,startLine);
  }

  kseq_destroy(FQseq);

  return NULL;
}

#ifdef __WITH_MAIN__

int main(int argc,char **argv){
  argStruct *mypars = NULL;
  mypars = getpars(argc,argv);
  
  // Initate parameters

  const char* Amplicon_in_fp = mypars->Amplicon_in_pars;
  const char* Amplicon_out_fp = mypars->Amplicon_out_pars;
  int threads = mypars->Threads;
  char *Briggs = mypars->BriggsBiotin;
  char *Indel = mypars->Indel;
  //const char* fastqFile = "Amplicon_in.fq";
  long int Seed = mypars->Seed;


  // Count the total number of lines in the file
  long long totalLines = 0;

  BGZF* fp_tmp = bgzf_open(Amplicon_in_fp, "r");
  kstring_t linecounttmp;linecounttmp.s=NULL;linecounttmp.l=linecounttmp.m=0; // Initialize a kstring_t structure
  while (bgzf_getline(fp_tmp, '\n', &linecounttmp) != -1){totalLines++;}
  free(linecounttmp.s);
  
  // Calculate the number of lines per thread
  size_t no_reads = totalLines/4;
  size_t linesPerThread = totalLines / threads;
  bgzf_close(fp_tmp);

  int modulovalue;
  if (no_reads > 100){
    modulovalue = 10;
  }
  else{ 
    modulovalue = 1;
  }
  size_t moduloread = no_reads/modulovalue;

  //printf("Total lines %zu \t Total reads %zu \t lines pr threads %zu \n",totalLines,no_reads,linesPerThread);

  //generating mismatch matrix to parse for each string
  double* MisMatchFreqArray = new double[LENS];
  int mismatchcyclelength = 0;
  int doMisMatchErr = 0;
  if (mypars->SubProfile != NULL){
    MisMatchFreqArray = MisMatchFileArray(MisMatchFreqArray,mypars->SubProfile,mismatchcyclelength);
    doMisMatchErr = 1;
  }

  if(strcasecmp("-indel",*argv)==0){
    mypars->Indel = strdup(*(++argv));
  }

  BGZF* fp = bgzf_open(Amplicon_in_fp, "r");
  if (fp == NULL) {
    fprintf(stderr, "Error opening the FastQ file.\n");
    return 1;
  }

  BGZF* amplicon_out = bgzf_open(Amplicon_out_fp, "wu");
  if (amplicon_out == NULL) {
    fprintf(stderr, "Error opening output file.\n");
    return 1;
  }

  // Create an array to hold thread IDs dynamically
  pthread_t* mythreads = new pthread_t[threads];

  // Create an array to hold thread arguments dynamically
  struct_for_amplicon_threads* amp_thread_struct = new struct_for_amplicon_threads[threads];

  // Create threads dynamically
  for (int i = 0; i < threads; ++i) {
    int startLine = i * linesPerThread+1;
    int endLine = (i == threads - 1) ? totalLines : startLine + linesPerThread - 1;

    //fprintf(stderr, "Thread %d reads in line start %d to line end %d\n", i, startLine, endLine);
    amp_thread_struct[i].moduloread = moduloread;
    amp_thread_struct[i].amplicon_in_fp = fp;
    amp_thread_struct[i].amplicon_out_fp = amplicon_out;
    amp_thread_struct[i].Briggs = Briggs;
    amp_thread_struct[i].startLine = startLine;
    amp_thread_struct[i].endLine = endLine;
    amp_thread_struct[i].threadid = i;
    amp_thread_struct[i].Seed = Seed; 

    // 3) misincorporation matrix
    amp_thread_struct[i].MisMatch = MisMatchFreqArray;
    amp_thread_struct[i].MisLength = (int) mismatchcyclelength;
    amp_thread_struct[i].doMisMatchErr = doMisMatchErr;

    // Random indels
    amp_thread_struct[i].Indel = Indel;

    // Create each thread
    pthread_create(&mythreads[i], NULL, ProcessChunk, &amp_thread_struct[i]);
  }
  
  // Wait for all threads to finish
  for (int i = 0; i < threads; ++i) {
    pthread_join(mythreads[i], NULL);
    //fprintf(stderr, "Thread %d finished\n", i+1);
  }

  // Delete allocated memory
  delete[] mythreads;
  delete[] amp_thread_struct;

  // Close the files
  bgzf_close(amplicon_out);
  bgzf_close(fp);

  fprintf(stderr, "done writing the altered amplicon file\n");
  
  return 0;
}
#endif

/*
g++ Amplicon.cpp -lz -lm -lbz2 -llzma -lpthread -lcurl -lcrypto ../mrand.o ../Briggs.o ../NtSubModels.o ../add_indels.o ../../htslib/libhts.a -D __WITH_MAIN__ -o Amplicon

./Amplicon --amplicon Amplicon_in.fq -m b,0.024,0.36,0.68,0.0097 -mf ../Test_Examples/MisincorpFile.txt --output Amplicon_out.fq

Deletions
./Amplicon --amplicon Amplicon_in.fq -indel 0.0,0.5,0.0,0.9 --output Amplicon_out.fq -t 1

Insertions
./Amplicon --amplicon Amplicon_in.fq -indel 0.05,0.0,0.1,0.0 --output Amplicon_out.fq -t 1

./Amplicon --amplicon Amplicon_in.fq --output Amplicon_out.fq --threads 2


*/

/*
  // CHUNK
  //Calculate the virtual offset for the beginning of line 100
    int targetLine = 100;
    int offset = bgzf_tell(fp);  // Get the current offset
    int line = 0;

    kseq_t *seq = kseq_init(fp);

    while (kseq_read(seq) >= 0 && line < targetLine) {
        offset = bgzf_tell(fp);
        line++;
    }

    // Use bgzf_seek to set the file position to the beginning of line 100
    bgzf_seek(fp, offset, SEEK_SET);

    // Read and process lines 100 to 200
    while (kseq_read(seq) >= 0 && line < targetLine + 100) {
        printf("Header: %s\n", seq->name.s);
        printf("Sequence: %s\n", seq->seq.s);
        printf("Quality: %s\n", seq->qual.s);

        line++;
    }

  kseq_destroy(seq);
  bgzf_close(fp);
  */



  /*
  READ IN
  kseq_t *seq = kseq_init(fp);
  while (kseq_read(seq) >= 0) {
    FastQRecord record;
    record.header = strdup(seq->name.s);
    record.sequence = strdup(seq->seq.s);
    record.quality = strdup(seq->qual.s);

    // Process the current record as needed
    printf("Header: %s\n", record.header);
    printf("Sequence: %s\n", record.sequence);
    printf("Quality: %s\n", record.quality);

    // Free memory allocated by strdup
    free(record.header);
    free(record.sequence);
    free(record.quality);
    printf("done freeing\n");
  }
  kseq_destroy(seq);
  bgzf_close(fp);
  */
